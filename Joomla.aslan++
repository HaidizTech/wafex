specification Joomla
channel_model CCM

entity Environment {
  
	symbols
		sqli: text; 	%sql injection payload
		webapplication, database: agent;
		nonpublic dashboard: text;
		nonpublic secureFolder: text;	
		nonpublic errorPage: text;

		%databses
		errorsql: text; %any possible SQLi payload that generates an informative error

		%DBMS
		nonpublic inDB(message): fact;
		nonpublic error(message): fact;
		nonpublic preparedStatement(message): message;
		nonpublic query(message): message;


		%info about the result of a SQL query
		nonpublic tuple(message): message;
		nonpublic no_tuple: text; 

		%database structure
		users: text;
		uname: text;
		upwd: text;
		articles: text;
		aid: text;
		nonpublic valid_value : text;
		isInDB(message): fact;
	
		% common
		get: text;	
		post: text;
		% request 
		request(message): message;	
		% response
		response(message): message;	
		article_page: text;
		login_page: text;

	clauses
		%DBMS (behavior)
		db_hc_ev(M):	inDB(M.sqli);
		db_hc_error(M):	error(errorsql.M) :- inDB(errorsql.M) ;


% Concretization:
% - the database is interal to the webapplication
% - whenever a cookie is received in an HTTP response, include it in the next request (if the domain matches)
% - hidden field (protection to CSRF). In order to get this field we first need to perform a request on a page X
%   and then retrive the field in the form. (what if AJAX, asynchronous request or requested triggered in javascript?)
% what if, for each request, we represent the URL of the request, the form name and the map real_param_name <-> abstract_param_name.
% we then make a request to URL in order to retrieve the page, we retrive the form name and its params, and we create a new request?

entity Session(Webapplication: agent) {

	entity Webapplication(Actor:agent) {
		symbols
			Searchquery: message;		
			Username, Password: message;
			IP: agent;
			SQLquery,Query,SQLresponse,SQLresponse2,Response: message;
			SQLparam1, SQLparam2 : message;
			NonceWA,NonceDB : text;
			valid_username: text;
			valid_password: text;

		body{
		
			% Search: in here we model the presence of a search field.
			% a search query is issued with a SQLi that retrieves username
			% and password
			%@ url_request http://www.example.com/search.php?field=Searchquery
			
			%? ->* Actor: ?IP.articles.aid.(?Searchquery);					
			? ->* Actor: ?IP.request(article_page.(?Searchquery));					
			SQLquery := Searchquery;

			% at this point we should talk to the database, but we're now
			% embedding its behavior in here
		
			% raw query	
			select{
				on(inDB(SQLquery) | error(SQLquery)):{
					Response :=  tuple(SQLquery);
				}
	
				on(!(inDB(SQLquery))):{
					Response :=  no_tuple;
				}
			}

			
			select{on(Response = tuple(SQLquery)):{
				if(!(error(SQLquery))){
					Actor ->* IP: response(tuple(SQLquery));
				}else{
					Actor ->* IP: response(errorPage.tuple(SQLquery));
				}
			}}
			
			SQLquery := fresh();
			Response := fresh();

			% Login: in here I expect to receive something that is a function of
			% tuple().
			%@ url_request http://www.example.com/login.php?username=Username&password=Password

			select{on(IP ->* Actor: request(login_page.users.uname.?Username)):{  						
				SQLparam1 := Username;
				%assert b: SQLquery != tuple(?);
				select{on( SQLparam1 = tuple(?) ):{
				% we simulate a preparedStatement is executed
					Response := no_tuple;
				}}
				select{on( Response = no_tuple):{
					Actor ->* IP: response(secureFolder);
				}}
			}}
		}
	}

	body{ %of session
		new Webapplication(webapplication);  
	}

	goals %of session 
		authorization: [](!(iknows(secureFolder))); %data extraction + authentication bypass
		%authorization: [](!(iknows(tuple(?)))); %data extraction + authentication bypass

}

body{ %of Environment
	% describe valid db content
	isInDB(tuple(?));
	isInDB(valid_value);
	new Session(webapplication);
}

}
