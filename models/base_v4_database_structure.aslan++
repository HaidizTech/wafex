% This is version 2 of the base aslan++ file
% where I reduce the number of nonce

specification joomla
channel_model CCM

entity Environment {
 

 types
		mytype < message;

	symbols
		sqli: text; 			%sql injection payload
		path_injection: text; 		%valid file
		xss: text; 		% XSS payload
		evil_file: text; 		%valid file
		honest, webapplication, database,filesystem: agent;
		nonpublic dashboard: text;
		nonpublic adminPanel: text;	
		nonpublic loginPage: text;	
		nonpublic errorPage: text;
		nonpublic viewHistory: text;
		nonpublic secureFile: text;
		nonpublic hknows : message set;
		option: text;
		view: text;
		upload, file,u,l,p : text;
		s : text;
		nonpublic ack: text;
		nonpublic sanitized(message) : message;
		redirect(message) : fact;

		%databses
		errorsql: text; %any possible SQLi payload that generates an informative error

		%DBMS
		nonpublic inDB(message): fact;
		nonpublic error(message): fact;
		nonpublic sanitizedQuery(message): message;
		nonpublic query(message set,message): message;
		nonpublic query2(message): message;
		nonpublic insert(message set,message): message;
		nonpublic update(message set,message,message): message;
		nonpublic delete(message set,message): message;
		nonpublic new_query(message set,message): message;

		%Filesystem
		nonpublic readFile(message): message;
		nonpublic file(message): message;
		nonpublic newFile(message): message;
		nonpublic inFS(message): fact;
		nonpublic inFS_DB(message): fact;
		nonpublic isInFS(message): fact;
		nonpublic writeFile(message): message;
		nonpublic no_file : text;

		%info about the result of a SQL query
		nonpublic tuple(message): message;
		nonpublic no_tuple: text;


		nonceUsed(message) : fact;
		cookieUsed(message) : fact;

		% request 
		% page, parameters, cookie
		http_request(message, message, message): message;	

		% response
		% page, result
		http_response(message, message): message;	

		% none parameter
		none : text;

		@symbolsenv

	clauses
		%DBMS (behavior)
		db_hc_ev(M)  : inDB((sqli.?).M);
		db_hc_ev_2(M): inDB(sqli.M);
		db_hc_ev_3(M): inDB(sqli);
		db_hc_ev_4(M): inDB(?.sqli);
		%db_hc_ev_2(M): inDB(M) :- M = (sqli.?).?;
		%db_hc_ev_3(M): inDB(sanitized(M));

		%FILESYSTEM (behavior)
		fs_hc_ev(M)  : inFS(path_injection.M);
		fs_hc_ev_2(M): inFS(M) :- isInFS(M);
		%fs_hc_ev_3(F)  : inFS(sanitized(F));


entity Session(Honest, Webapplication, Database, Filesystem: agent) {

symbols
			Database_string : message;

	entity Webapplication(Honest, Actor, Database, Filesystem: agent) {
		@webapp
	}


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% HONEST ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  entity Honest(Actor, Webapplication : agent){
	
		symbols
		  Response, RResponse, Something : message;
			Page, Params, Cookie, Tag : message;
			Redirect : message;
			WebNonce : text;
			nonpublic requestSent(message, message): fact;
		
		body{
				 while(true){
				 		select{
				 				% This represent the intruder that sent a link to
				 				% the honest agent used for Reflected XSS but also for CSRF
				 				 on( i *->* Actor : ?Page.?Params.?Tag ):{
				 						%assert o: Page !=  index | Params != u.s.xss.?.s.p.s.none | !hknows->contains(?) | Tag != tag1;
				 						%assert o: Page !=  insertPage | Params != comment.s.xss.insertPage | Tag != tag1;
				 						%assert h: exists M. hknows->contains(M) & cookieUsed(M);
				 						Cookie := ?;
				 						WebNonce := fresh();
				 						Actor *->* Webapplication : http_request(Page,Params,Cookie).Tag.WebNonce;
				 						requestSent(Tag, WebNonce);
				 					}
				 				% with this rule we represent that the honest agent aka the
				 				% oracle, receives an XSS constant and forwards his knowledge
				 				% to the intruder
				 				%	on( Webapplication *->* Actor : http_response(?Page,?Params).Tag):{
				 				%	%assert g: !hknows->contains(?) |  (Page != test);
				 				%		select{
				 				%			on (Params = ?.xss.?Redirect ):{
				 				%					% redirecting the user aka CSRF
				 				%					Actor *->* Webapplication : http_request(Redirect,none,none);
				 				%					% I suppose that after this line I should put
				 				%					% the answer generated by the web application
				 				%					Webapplication *->* Actor : http_response(?Response,?RResponse);
				 				%					redirect(Redirect);
				 				%					hknows->add(Response);
				 				%					hknows->add(RResponse);
				 				%			}
				 				%		}
				 				% 	}
				 				% GENERAL HONEST RULE
				 				% this rule would allow the honest entity (browser?) to perform
				 				% any kind of request without the need of representing it
				 				% in the base model
				 				% IMPORTANT: this rule should stay here otherwise the order
				 				% of execution is messed
				 				on(true):{
				 						% note: we might need to create one of this rule for every possibile
				 						% request that can be performed by the web application. This
				 						% fot two reasons:
				 						% 1) optimization, so to avoid --nb N when executing CL-Atse
				 						% 2) tie requests and responses specifying the tag number

				 						% the honest agent picks a random tag for which request he wants to perform
				 						Tag := ?;
				 						WebNonce := fresh();
				 						Actor *->* Webapplication : http_request(?,?,?).Tag.WebNonce;
				 						requestSent(Tag, WebNonce);
				 				}

				 					% general rule for the honest user when he receives something
				 					on(Webapplication *->* Actor : http_response(?Response,?RResponse).?Tag.?WebNonce):{
				 						select{ on(requestSent(Tag, WebNonce)):{
				 							select{
				 								% XSS for browsing redirection
				 								on (RResponse = ?.xss.?Redirect):{
				 										Params := ?;
				 										Cookie := ?;
				 										Tag := ?;
				 										WebNonce := fresh();
				 										% redirecting the user aka CSRF
				 										Actor *->* Webapplication : http_request(Redirect,Params,Cookie).Tag.WebNonce;
				 										redirect(Redirect);
				 										Webapplication *->* Actor : http_response(?Response,?RResponse).Tag.WebNonce;
				 										hknows->add(Response);
				 										hknows->add(RResponse);
				 								}
				 								% XSS for stealing the user's knowledge
				 								on (RResponse = ?.xss.?Redirect):{
				 												Actor *->* i : hknows;
				 										%select{on(hknows->contains(?)):{
				 										%		Actor *->* i : hknows;
				 										%}}
				 								}
				 				 			}
				 						}}
				 					}
				 					
				 		} %end select
				 } %end while
		} % end body
 } % end entity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% END HONEST ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% DATABASE ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%TODO: fix SQLquery is just one message
	
	entity Database(Webapplication, Actor, Filesystem: agent){
		symbols
			NonceWA,NonceDB,NonceFS: text;
			SQLquery,SQLnew, File: message;
			Sql, Val : message;
			Table : message set;

			% this variable represents all the content of the database
	
		body{
				while(true){
						select{ 
								% on(Webapplication *->* Actor: query(sanitized(?SQLquery)).?NonceWA ):{
								% 	select{on(SQLquery = tuple(?).tuple(?) & SQLquery != tuple(file(?)).? & SQLquery != tuple(newFile(?)).? ):{
								% 		Actor *->* Webapplication: no_tuple.NonceWA;
								% 	}}
								% }
								% on(Webapplication *->* Actor: query2(?SQLquery).?NonceWA):{
								% 				select{
								% 					on(inDB(SQLquery)):{
								% 						Actor *->* Webapplication: tuple(SQLquery).NonceWA;
								% 					}
								% 					on((!inDB(SQLquery) & SQLquery != sanitized(?)) ):{
								% 						Actor *->* Webapplication: no_tuple.NonceWA;
								% 					}
								% 				}
								% }
								% get from the database sanitized
								on(Webapplication *->* Actor: query(?Table,sanitized(?SQLquery)).?NonceWA):{
									select{on(SQLquery != tuple(file(?)).? & SQLquery != tuple(newFile(?)).? ):{
												select{on(Table->contains(SQLquery)):{
													Actor *->* Webapplication : SQLquery.NonceWA;
												}
									}}}
								}
								% get from the database
								on(Webapplication *->* Actor: query(?Table,?SQLquery).?NonceWA):{
										select{
												% get me a random value inside the table
												on(Table->contains(SQLquery.?Val)):{
													Actor *->* Webapplication : Val.NonceWA;
												}
												on(inDB(SQLquery)):{
													% Actor *->* Webapplication : tuple(SQLquery).NonceWA;
													% send back all the string representation fo the table
													Actor *->* Webapplication : Database_string.NonceWA;
												}
										}
								}
								% insert into the database
								on(Webapplication *->* Actor: insert(?Table,?SQLquery).?NonceWA):{
									if(inDB(SQLquery)){
										Database *->* Webapplication : Database_string.NonceWA;
									}else{
										% insert will always succeed
										Table->add(SQLquery);
										% maintain a string representation for the table
										Database_string := Database_string.SQLquery;
									}
								}

								% update into the database
								on(Webapplication *->* Actor: update(?Table,?SQLquery, ?SQLnew).?NonceWA):{
									if(inDB(SQLquery)){
										Database *->* Webapplication : Database_string.NonceWA;
									}else{
										% insert will always succeed
										Table->remove(SQLquery);
										Table->add(SQLnew);
										% maintain a string representation for the table
										Database_string := Database_string.SQLnew;
									}
								}

								
								% on(Webapplication *->* Actor: query(?SQLquery).?NonceWA ):{
								% 				select{
								% 						on(inDB(SQLquery)):{
								% 							Actor *->* Webapplication: tuple(SQLquery).NonceWA;
								% 						}

								% 						%extend the database for reading from filesystem
								% 						on(inDB(SQLquery)):{
								% 							NonceDB := fresh();
								% 							select{on( SQLquery = (?Sql.?File).?):{
								% 									Actor *->* Filesystem: readFile(File).NonceDB;
								% 									select{on(Filesystem *->* Actor : file(File).NonceDB):{
								% 											Actor *->* Webapplication : tuple(file(File)).NonceWA;
								% 									}}
								% 							}}
								% 						}	
								% 						%extend the database form writing to filesystem
								% 						on(inDB(SQLquery)):{
								% 								NonceDB := fresh();
								% 								% when coming here, write a random file to filesystem.
								% 								% when returning, the intruder will get to know the newly
								% 								% created file
								% 						
								% 								% writing a file with a valid sql. If we assume that something is
								% 								% inDB valid means that the pattern is validConstant.fileToWrite.remainingMessage
								% 								select{on( SQLquery = (?Sql.?File).?):{
								% 														Actor *->* Filesystem: writeFile(File).NonceDB;
								% 														Actor *->* Webapplication : tuple(newFile(File)).NonceWA;
								% 									}}
								% 						}
								% 						
								% 						on((!inDB(SQLquery) & SQLquery != sanitized(?)) ):{
								% 							Actor *->* Webapplication: no_tuple.NonceWA;
								% 						}
								% 				}
								% }%end on
			} %select
		} %while 
	} %body
  }%dbEntity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% FILESYSTEM ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	entity Filesystem(Webapplication, Actor: agent){

			symbols
				Nonce1, Nonce2: text;
				Path : message;
				Entity : agent;

			body{
				while(true){
					select{
						% the webapplication asks to read the filesystem 
						on(?Entity *->* Actor : readFile(?Path).?Nonce1):{
							select{
								on(inFS(Path)):{
										Actor *->* Entity : file(Path).Nonce1;
								}
								on( inFS(Path)):{
										Actor *->* Entity : no_file.Nonce1;
								}
							}%select(on)
						} %on webapp -> fs
						on(?Entity *->* Actor : writeFile(?Path).?Nonce1):{
								isInFS(Path); % from this point on, inFS(Path) holds for the new path
								%% Actor *->* Webapplication : newFile(Path).Nonce2;
								% no return for now
						} %writeFile

					}%select
				}%while
			}%body
	}%fs_entity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	body{ %of session
		new Webapplication(honest, webapplication, database, filesystem);  
		new Database(webapplication, database, filesystem);
		new Filesystem(webapplication,filesystem);
		new Honest(honest,webapplication);
		@sessionbody
	}

	goals %of session 
		ggg:
				@goals
}

body{ %of Environment
@bodyenv
	new Session(honest,webapplication, database, filesystem);
}

}
