specification joomla
channel_model CCM

entity Environment {
 

 types
		mytype < message;

	symbols
		sqli: text; 			%sql injection payload
		path_injection: text; 		%valid file
		xss: text; 		% XSS payload
		evil_file: text; 		%valid file
		honest, webapplication, database,filesystem: agent;
		nonpublic dashboard: text;
		nonpublic adminPanel: text;	
		nonpublic loginPage: text;	
		nonpublic errorPage: text;
		nonpublic viewHistory: text;
		nonpublic secureFile: text;
		nonpublic hknows : message set;
		option: text;
		view: text;
		upload, file,u,l,p, bob : text;
		s : text;
		nonpublic ack: text;
		nonpublic sanitized(message) : message;
		redirect(message) : fact;

		%databses
		errorsql: text; %any possible SQLi payload that generates an informative error

		%DBMS
		nonpublic inDB(message): fact;
		nonpublic error(message): fact;
		nonpublic sanitizedQuery(message): message;
		nonpublic query(message): message;
		nonpublic query2(message): message;

		%Filesystem
		nonpublic readFile(message): message;
		nonpublic file(message): message;
		nonpublic newFile(message): message;
		nonpublic inFS(message): fact;
		nonpublic inFS_DB(message): fact;
		nonpublic isInFS(message): fact;
		nonpublic writeFile(message): message;
		nonpublic no_file : text;

		%info about the result of a SQL query
		nonpublic tuple(message): message;
		nonpublic no_tuple: text; 


		nonceUsed(message) : fact;
		cookieUsed(message) : fact;

		% request 
		% page, parameters, cookie
		http_request(message, message, message): message;	

		% response
		% page, result
		http_response(message, message): message;	

		% none parameter
		none : text;

		@symbolsenv

	clauses
		%DBMS (behavior)LOAFER
		db_hc_ev(M)  : inDB((sqli.?).M); 
		db_hc_ev_2(M): inDB(sqli.M);
		db_hc_ev_3(M): inDB(sqli);
		%db_hc_ev_2(M): inDB(M) :- M = (sqli.?).?; 
		%db_hc_ev_3(M): inDB(sanitized(M)); 

		%FILESYSTEM (behavior)
		fs_hc_ev(M)  : inFS(path_injection.M);
		fs_hc_ev_2(M): inFS(M) :- isInFS(M);
		%fs_hc_ev_3(F)  : inFS(sanitized(F));


entity Session(Honest, Webapplication, Database, Filesystem: agent) {

	entity Webapplication(Honest, Actor, Database, Filesystem: agent) {
		@webapp
	}


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% HONEST ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

  entity Honest(Actor, Webapplication : agent){
	
		symbols
		  Response, RResponse, Something : message;
			Page, Params, Cookie, Tag : message;
			Redirect : message;
			NonceH : text;
		
		body{
				while(true){
						select{
								% This represent the intruder that sent a link to 
								% the honest agent
								 on( i *->* Actor : ?Page.?Params.none.?Tag ):{
								 		Actor *->* Webapplication : Actor.http_request(Page,Params,none).Tag;
										%assert o: Page !=  index | Params != u.s.xss.?.s.p.s.none | !hknows->contains(?) | Tag != tag1;
										%assert o: Page !=  index | Params != u.s.xss.?.s.p.s.none | Tag != tag1;
										%assert h: exists M. hknows->contains(M) & cookieUsed(M);
								 		select{ 
								 				% with this rule we represent that the honest agent aka the
								 				% oracle, receives an XSS constant and forwards his knowledge
								 				% to the intruder
								 				on( Webapplication *->* Actor : http_response(?Page,?Params).?NonceH.Tag):{
														%assert g: !hknows->contains(?) |  (Page != test);
								 						select{
								 								on (Params = xss.?Redirect & !nonceUsed(NonceH)):{
																		%assert g: !hknows->contains(?) ;
								 										% stealing the user's knowledge
								 										nonceUsed(NonceH);
																		select{on(hknows->contains(?)):{
																				Actor *->* i : hknows;
																				assert h: exists M. hknows->contains(M) & cookieUsed(M);
																		}}
								 								}
								 								 on (Params = ?.xss.?Redirect & !nonceUsed(NonceH)):{
								 								 		% redirecting the user aka CSRF
								 								 		nonceUsed(NonceH);
								 								 		redirect(Redirect);
								 								 		Actor *->* Webapplication : Actor.http_request(Redirect,none,none);
								 								 		% I suppose that after this line I should put
								 								 		% the answer generated by the web application
								 								 		Webapplication *->* Actor : http_response(?Response,?RResponse);
								 								 		hknows->add(Response);
								 								 		hknows->add(RResponse);
								 								 }
								 						}
								 				}
								 		}
								 } % end on
								% GENERAL HONEST RULE
								% this rule would allow the honest entity (browser?) to perform
								% any kind of request without the need of representing it
								% in the mase model (hopefuly)
								% IMPORTANT: this rule should stay here otherwise the order
								% of execution is messed
								on(true):{
										% the honest agent wants to make a request
										Params := ?;
										select{on(Params = ?):{
										%select{on(Params = u.s.?.s.p.s.p):{
									Actor *->* Webapplication : Actor.http_request(?,Params,?).tag3;
									% note: we might need to create one of this rule for every possibile
									% request that can be performed by the web application. This
									% fot two reasons:
									% 1) optimization, so to avoid --nb N when executing CL-Atse
									% 2) bonding request and response specifying the tag number
									Webapplication *->* Actor : http_response(?Response,?RResponse).?NonceH.tag3;
										%assert t: false;

									%assert t: Response != test_back;
									% the following select is used for avoiding the honest
									% to attack himself
									select{on(RResponse != xss.?  & !nonceUsed(NonceH)):{
										nonceUsed(NonceH);
										%assert b:Response != test_back;
										hknows->add(Response);
										hknows->add(RResponse);
										%assert h: !cookieUsed(RResponse);
										%assert g: !hknows->contains(?);
									}}
								} % end on
								}} % select on avoid xss in params

						} %end select
				} %end while
		} % end body
 } % end entity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% END HONEST ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% DATABASE ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%TODO: fix SQLquery is just one message
	
	entity Database(Webapplication, Actor, Filesystem: agent){
		symbols
			NonceWA,NonceDB,NonceFS: text;
			SQLquery, File: message;
			Sql : message;
	
		body{
				while(true){
						select{ 
								on(Webapplication *->* Actor: query(sanitized(?SQLquery)).?NonceWA ):{
									select{on( !nonceUsed(NonceWA) & SQLquery = tuple(?) & SQLquery != tuple(file(?)) & SQLquery != tuple(newFile(?) )):{
										nonceUsed(NonceWA);
										NonceDB := fresh();
										Actor *->* Webapplication: no_tuple.NonceDB;
									}}
								}
								on(Webapplication *->* Actor: query2(?SQLquery).?NonceWA):{
										select{	on( !nonceUsed(NonceWA)):{
												nonceUsed(NonceWA);
												select{
													on(inDB(SQLquery)):{
														NonceDB := fresh();
														Actor *->* Webapplication: tuple(SQLquery).NonceDB;
													}
													on((!inDB(SQLquery) & SQLquery != sanitized(?)) ):{
														NonceDB := fresh();
														Actor *->* Webapplication: no_tuple.NonceDB;
													}
												}
										}}
								}
								on(Webapplication *->* Actor: query(?SQLquery).?NonceWA ):{
										select{	on( !nonceUsed(NonceWA)):{
												nonceUsed(NonceWA);
												select{
														on(inDB(SQLquery)):{
															NonceDB := fresh();
															Actor *->* Webapplication: tuple(SQLquery).NonceDB;
														}

														%extend the database for reading from filesystem
														on(inDB(SQLquery)):{
															NonceDB := fresh();
															select{on( SQLquery = (?Sql.?File).?):{
																	Actor *->* Filesystem: readFile(File).NonceDB;
																	select{on(Filesystem *->* Actor : file(File).?NonceFS):{
																		select{	on( !nonceUsed(NonceFS)):{
																			nonceUsed(NonceFS);
																			NonceDB := fresh();
																			Actor *->* Webapplication : tuple(file(File)).NonceDB;
																		}}
																	}}
															}}
														}	
														%extend the database form writing to filesystem
														on(inDB(SQLquery)):{
																NonceDB := fresh();
																% when coming here, write a random file to filesystem.
																% when returning, the intruder will get to know the newly
																% created file
														
																% writing a file with a valid sql. If we assume that something is
																% inDB valid means that the pattern is validConstant.fileToWrite.remainingMessage
																select{on( SQLquery = (?Sql.?File).?):{
																					Actor *->* Filesystem: writeFile(File).NonceDB;
																							nonceUsed(NonceFS);
																							NonceDB := fresh();
																							Actor *->* Webapplication : tuple(newFile(File)).NonceDB;
																	}}
														}
														
														on((!inDB(SQLquery) & SQLquery != sanitized(?)) ):{
															NonceDB := fresh();
															Actor *->* Webapplication: no_tuple.NonceDB;
														}
												}
										}} %end select
								}%end on
			} %select
		} %while 
	} %body
  }%dbEntity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% FILESYSTEM ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	entity Filesystem(Webapplication, Actor: agent){

			symbols
				Nonce1, Nonce2: text;
				Path : message;
				Entity : agent;

			body{
				while(true){
					select{
						% the webapplication asks to read the filesystem 
						on(?Entity *->* Actor : readFile(?Path).?Nonce1):{
							select{
								on( !nonceUsed(Nonce1) & inFS(Path)):{
										nonceUsed(Nonce1);
										Nonce2 := fresh();
										Actor *->* Entity : file(Path).Nonce2;
								}
								on( !nonceUsed(Nonce1) & inFS(Path)):{
										nonceUsed(Nonce1);
										Nonce2 := fresh();
										Actor *->* Entity : no_file.Nonce2;
								}
							}%select(on)
						} %on webapp -> fs
						on(?Entity *->* Actor : writeFile(?Path).?Nonce1):{
				  			select{on( !nonceUsed(Nonce1)):{
								nonceUsed(Nonce1);
								Nonce2 := fresh();
								isInFS(Path); % from this point on, inFS(Path) holds for the new path
								%% Actor *->* Webapplication : newFile(Path).Nonce2;
								% no return for now
							}}
						} %writeFile

					}%select
				}%while
			}%body
	}%fs_entity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	body{ %of session
		new Webapplication(honest, webapplication, database, filesystem);  
		new Database(webapplication, database, filesystem);
		new Filesystem(webapplication,filesystem);
		new Honest(honest,webapplication);
	}

	goals %of session 
		ggg:
				@goals
}

body{ %of Environment
@bodyenv
	new Session(honest,webapplication, database, filesystem);
}

}
