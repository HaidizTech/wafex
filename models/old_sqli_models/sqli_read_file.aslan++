specification sqli_read_file
channel_model CCM

entity Environment {
  
	symbols
		sqli: text; 						%sql injection payload
		path_injection: text; 	%file path payload (like path traversal)
		evil_file: text; 				%valid malicious file which enable upload of server-side code

		webapplication, database, filesystem: agent;
		nonpublic dashboard: text;
		nonpublic adminPanel: text;	
		nonpublic loginPage: text;	
		nonpublic errorPage: text;
		nonpublic viewHistory: text;
		secureFile, htpwd: text;
		option: text;
		view: text;
		upload, file,u,p, bob,page : text;
		nonpublic ack: text;

		%databses
		errorsql: text; %any possible SQLi payload that generates an informative error

		%DBMS
		nonpublic inDB(message): fact;
		nonpublic error(message): fact;
		nonpublic sanitizedQuery(message): message;
		nonpublic query(message): message;
		%info about the result of a SQL query
		nonpublic tuple(message): message;
		nonpublic no_tuple: text; 

		%Filesystem
		nonpublic readFile(message): message;
		nonpublic f_file(message): message;
		nonpublic new_file(message): message;
		nonpublic inFS(message): fact;
		nonpublic isInFS(message): fact;
		nonpublic writeFile(message): message;


		%web application constants
		header_cookie : text;
		username : text;
		password : text;
		listselect : text;

		noninvertible hash(message) : message;

		% request 
		http_request(message): message;	
		% response
		http_response(message): message;	
		% used nonce marker
		nonceUsed(message) : fact;

		% messages tagss
		tag1,tag2,tag3,tag4 : text;

	clauses
		%DBMS (behavior)
		%multiple HCs are required for representing multiple messages patterns
		db_hc_ev(M):		inDB((sqli.?).M); 
		db_hc_ev_2(M):	inDB(sqli.M); 

		%FILESYSTEM (behavior)
		fs_hc_ev(F):		inFS(path_injection.F);
		fs_hc_ev_3(F):	inFS(F) :- isInFS(F);


entity Session(Webapplication, Database, Filesystem: agent) {

	entity Webapplication(Actor, Database, Filesystem: agent) {
		symbols
			Option,View,Ordering,Typeid: text;
			Username, Password, Cookie, File, RemoteShell, Path: message;
			IP: agent;
			SQLquery, SQLresponse, Search: message;
			NonceWA,NonceDB,NonceFS : text;

		body{


		while(true){
			select{

				% implementing fileUpload functionality
			%	on( ? *->* Actor : ?IP.http_request(upload.?File).tag1):{
			%		NonceWA := fresh();
			%		Actor *->* Filesystem : writeFile(File).NonceWA;

			%	}

				% implementing include functionality	
				% this is not working, the only difference with the one underneath request is that
				% we put the Filesystem -> Actor in a select_on statement
				%on( ? *->* Actor : ?IP.http_request(page.?File).tag1):{
				%	NonceWA := fresh();
				%	Actor *->* Filesystem : readFile(File).NonceWA;
				%	select{ on( Filesystem *->* Actor : f_file(File).NonceFS ):{
				%		select{ on(!nonceUsed(NonceFS)):{
				%			nonceUsed(NonceFS);
				%			Actor *->* IP : f_file(File);
				%		}}
				%	}}

				%}


				% implementing include functionality
			%	on( ? *->* Actor : ?IP.http_request(page.?Path).tag2 ):{
			%			NonceWA := fresh();
			%			Actor *->* Filesystem : readFile(Path).NonceWA;
			%			Filesystem *->* Actor : f_file(Path).?NonceFS;
			%				select{on(!nonceUsed(NonceFS)):{
			%					nonceUsed(NonceFS);
			%						Actor *->* IP : f_file(Path);
			%				}}

			%	}


			% form based authentication
			on( ? *->* Actor: ?IP.http_request(u.?Username.p.?Password).tag1 ): {
							% arity problem, we are missing the password check which should be hashed
							SQLquery := Username;

							NonceWA := fresh();
							Actor *->* Database : query(SQLquery).NonceWA;

							select{
									on(Database *->* Actor : tuple(?SQLresponse).?NonceDB):{
										select{
											on( !nonceUsed(NonceDB)):{
												nonceUsed(NonceDB);
												Actor *->* IP : http_response(tuple(SQLresponse));
										}}
									}
							}
				} 


			% http basic authentication login
			on( ? *->* Actor: ?IP.http_request(u.?Username.p.?Password).tag3 ): {
					NonceWA := fresh();
				
						% I guess that theoretically we can leave it as f_file(?) and
						% change it when talking about the concretization ... kinda makes sense
					%select{ on( Username = f_file(?) & Password = f_file(?) ):{
					select{ on( Username = f_file(htpwd) & Password = f_file(htpwd) ):{
						% now here we check that Username&Passowrd are in htpwd
						% in case Username&Password are function of f_file(?), access granted
						Actor *->* IP : http_response(adminPanel);

					}}
					


			}
				



				% this branch represents an uploaded server-side code that
				% reads from the filesystem
			%	on( ? *->* Actor : ?IP.http_request(evil_file.file.?Path).tag2 ):{
			%		select{on( isInFS(evil_file) & evil_file != Path):{ % means the file RemoteShell has been injected and the file I'm trying to
			%																													 % retrieve is not the same as the injected file
			%			NonceWA := fresh();
			%			Actor *->* Filesystem : readFile(Path).NonceWA;
			%			
			%			Filesystem *->* Actor : f_file(Path).?NonceFS;
			%				select{on(!nonceUsed(NonceFS)):{
			%					nonceUsed(NonceFS);
			%						Actor *->* IP : f_file(Path);
			%				}}

			%		}}
			%	}

			}%end select
		}%end while
		}%end body
		
	}


	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% DATABASE ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	entity Database(Webapplication, Actor, Filesystem: agent){
		symbols
			NonceWA,NonceDB,NonceFS: text;
			SQLquery, File: message;
			Sql : message;
	
		body{
			while(true){
	
			select{ 
				%TODO: fix SQLquery is just one message
				on(Webapplication *->* Actor: sanitizedQuery(?SQLquery).?NonceWA ):{
					select{on( !nonceUsed(NonceWA) & SQLquery = tuple(?) & SQLquery != tuple(f_file(?)) & SQLquery != tuple(new_file(?) )):{
						nonceUsed(NonceWA);
						NonceDB := fresh();
						Actor *->* Webapplication: no_tuple.NonceDB;
					}}
				}
				
				on(Webapplication *->* Actor: query(?SQLquery).?NonceWA ):{
					select{	on( !nonceUsed(NonceWA)):{
						nonceUsed(NonceWA);

						select{
							on(inDB(SQLquery)):{
								NonceDB := fresh();
								Actor *->* Webapplication: tuple(SQLquery).NonceDB;
							}
						 % extend the database to read from filesystem
							on(inDB(SQLquery)):{
								NonceDB := fresh();
								select{on( SQLquery = (?Sql.?File)):{
								Actor *->* Filesystem: readFile(File).NonceDB;

								select{on(Filesystem *->* Actor : f_file(File).?NonceFS):{
									select{	on( !nonceUsed(NonceFS)):{
										nonceUsed(NonceFS);
										NonceDB := fresh();
										Actor *->* Webapplication : tuple(f_file(File)).NonceDB;
									}}
								}}
							}}
							}	
	
	
						% extend the database to write to filesystem
							on(inDB(SQLquery)):{
								NonceDB := fresh();
								% when coming here, write a random file to filesystem.
								% when returning, the intruder will get to know the newly
								% created file

								% writing a file with a valid sql. If we assume that something is
								% inDB valid means that the pattern is validConstant.fileToWrite.remainingMessage
								select{on( SQLquery = (?Sql.?File).?):{
													Actor *->* Filesystem: writeFile(File).NonceDB;
													select{on(Filesystem *->* Actor : new_file(?File).?NonceFS):{
														select{	on( !nonceUsed(NonceFS)):{
															nonceUsed(NonceFS);
															NonceDB := fresh();
															Actor *->* Webapplication : tuple(new_file(File)).NonceDB;
														}}
													}}
									}}
								}
								


							on(!(inDB(SQLquery))):{
								NonceDB := fresh();
								Actor *->* Webapplication: no_tuple.NonceDB;
							}
						}
					}
				} %end select
			}%end on
			} %select	
		} %while 
	} %body
  }%dbEntity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	% FILESYSTEM ENTITY
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	entity Filesystem(Webapplication, Database, Actor: agent){

			symbols
				Nonce1, Nonce2: text;
				Path : message;

			body{
				while(true){
					select{
						% the webapplication asks to read the filesystem 
						on(Webapplication *->* Actor : readFile(?Path).?Nonce1):{
							select{on( !nonceUsed(Nonce1) & inFS(Path)):{
								nonceUsed(Nonce1);
								Nonce2 := fresh();
								Actor *->* Webapplication : f_file(Path).Nonce2;
								%assert bau: Path != path_injection.?;
							}}%select(on)
						} %on webapp -> fs
				  	on(Database *->* Actor : readFile(?Path).?Nonce1):{
				  			select{on( !nonceUsed(Nonce1) & inFS(Path)):{
				  				nonceUsed(Nonce1);
				  				Nonce2 := fresh();
				  				Actor *->* Database : f_file(Path).Nonce2;
				  			}}%select(on)
				  	} %on database -> fs
						% write to filesystem from the web app
						on(Webapplication *->* Actor : writeFile(?Path).?Nonce1):{
				  			select{on( !nonceUsed(Nonce1)):{
								nonceUsed(Nonce1);
								Nonce2 := fresh();
								isInFS(Path); % from this point on, inFS(Path) holds for the new path
								Actor *->* Webapplication : new_file(Path).Nonce2;
								% no return for now
							}}
						} %writeFile
						% write to filesystem from the database
						on(Database *->* Actor : writeFile(?Path).?Nonce1):{
				  			select{on( !nonceUsed(Nonce1)):{
								%assert bau: false;
								nonceUsed(Nonce1);
								Nonce2 := fresh();
								isInFS(Path); % from this point on, inFS(Path) holds for the new path
								Actor *->* Database : new_file(Path).Nonce2;
								% no return for now
							}}
						} %writeFile

					}%select
				}%while
			}%body
	}%fs_entity
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	body{ %of session
		new Webapplication(webapplication, database, filesystem);  
		new Database(webapplication, database, filesystem);
		new Filesystem(webapplication,database,filesystem);
	}

	goals %of session 
		authorization:
			[](!(iknows(adminPanel))); 																							%data extraction + authentication bypass
			%[](!(iknows(f_file(secureFile)))); 																							%data extraction + authentication bypass
			%[](!(iknows(f_file(?)))); 																									% filesystem access
			%[](!(isInFS(evil_file))); 																									% filesystem access
			%[]( forall M1. exists M2.!iknows(M1) & M1 = tuple(M2) &  M2 != f_file(?)); % database access
			%[](( forall M1. ( iknows(tuple(M1)) => M1 = f_file(?)))); 									% database access

			%[](( forall M1. M1 != f_file(?) => !(iknows(tuple(M1)) ))); 								% database access
			%[](!( forall M1 M2. (iknows(M1) & M1 = tuple(M2)) => M2 = f_file(?) ) ); 	% database access
}

body{ %of Environment
		%isInFS(secureFile);
		isInFS(htpwd);
	new Session(webapplication, database, filesystem);
}

}
