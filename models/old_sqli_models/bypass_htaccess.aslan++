specification bypass_htaccess
channel_model CCM

entity Environment {
 
 import Base;

	symbols



		%web application constants
		header_cookie : text;
		username : text;
		password : text;
		listselect : text;

		noninvertible hash(message) : message;


entity Session(Webapplication, Database, Filesystem: agent) {

	entity Webapplication(Actor, Database, Filesystem: agent) {
		symbols
			Option,View,Ordering,Typeid: text;
			Username, Password, Cookie, File, RemoteShell, Path: message;
			IP: agent;
			SQLquery, SQLresponse, Search: message;
			NonceWA,NonceDB,NonceFS : text;

		body{


		while(true){
			select{

				% implementing fileUpload functionality
			%	on( ? *->* Actor : ?IP.http_request(upload.?File).tag1):{
			%		NonceWA := fresh();
			%		Actor *->* Filesystem : writeFile(File).NonceWA;

			%	}

				% implementing include functionality	
				% this is not working, the only difference with the one underneath request is that
				% we put the Filesystem -> Actor in a select_on statement
				%on( ? *->* Actor : ?IP.http_request(page.?File).tag1):{
				%	NonceWA := fresh();
				%	Actor *->* Filesystem : readFile(File).NonceWA;
				%	select{ on( Filesystem *->* Actor : f_file(File).NonceFS ):{
				%		select{ on(!nonceUsed(NonceFS)):{
				%			nonceUsed(NonceFS);
				%			Actor *->* IP : f_file(File);
				%		}}
				%	}}

				%}


				% implementing include functionality
			%	on( ? *->* Actor : ?IP.http_request(page.?Path).tag2 ):{
			%			NonceWA := fresh();
			%			Actor *->* Filesystem : readFile(Path).NonceWA;
			%			Filesystem *->* Actor : f_file(Path).?NonceFS;
			%				select{on(!nonceUsed(NonceFS)):{
			%					nonceUsed(NonceFS);
			%						Actor *->* IP : f_file(Path);
			%				}}

			%	}


			% form based authentication
			on( ? *->* Actor: ?IP.http_request(u.?Username.p.?Password).tag1 ): {
							% arity problem, we are missing the password check which should be hashed
							SQLquery := Username;

							NonceWA := fresh();
							Actor *->* Database : query(SQLquery).NonceWA;

							select{
									on(Database *->* Actor : tuple(?SQLresponse).?NonceDB):{
										select{
											on( !nonceUsed(NonceDB)):{
												nonceUsed(NonceDB);
												Actor *->* IP : http_response(tuple(SQLresponse));
										}}
									}
							}
				} 


			% http basic authentication login
			on( ? *->* Actor: ?IP.http_request(u.?Username.p.?Password).tag3 ): {
					NonceWA := fresh();
				
						% I guess that theoretically we can leave it as f_file(?) and
						% change it when talking about the concretization ... kinda makes sense
					%select{ on( Username = f_file(?) & Password = f_file(?) ):{
					select{ on( Username = f_file(htpwd) & Password = f_file(htpwd) ):{
						% now here we check that Username&Passowrd are in htpwd
						% in case Username&Password are function of f_file(?), access granted
						Actor *->* IP : http_response(adminPanel);

					}}
					


			}
				



				% this branch represents an uploaded server-side code that
				% reads from the filesystem
			%	on( ? *->* Actor : ?IP.http_request(evil_file.file.?Path).tag2 ):{
			%		select{on( isInFS(evil_file) & evil_file != Path):{ % means the file RemoteShell has been injected and the file I'm trying to
			%																													 % retrieve is not the same as the injected file
			%			NonceWA := fresh();
			%			Actor *->* Filesystem : readFile(Path).NonceWA;
			%			
			%			Filesystem *->* Actor : f_file(Path).?NonceFS;
			%				select{on(!nonceUsed(NonceFS)):{
			%					nonceUsed(NonceFS);
			%						Actor *->* IP : f_file(Path);
			%				}}

			%		}}
			%	}

			}%end select
		}%end while
		}%end body
		
	}



	body{ %of session
		new Webapplication(webapplication, database, filesystem);  
		new Database(webapplication, database, filesystem);
		new Filesystem(webapplication,database,filesystem);
	}

	goals %of session 
		authorization:
			[](!(iknows(adminPanel))); 																							%data extraction + authentication bypass
			%[](!(iknows(f_file(secureFile)))); 																							%data extraction + authentication bypass
			%[](!(iknows(f_file(?)))); 																									% filesystem access
			%[](!(isInFS(evil_file))); 																									% filesystem access
			%[]( forall M1. exists M2.!iknows(M1) & M1 = tuple(M2) &  M2 != f_file(?)); % database access
			%[](( forall M1. ( iknows(tuple(M1)) => M1 = f_file(?)))); 									% database access

			%[](( forall M1. M1 != f_file(?) => !(iknows(tuple(M1)) ))); 								% database access
			%[](!( forall M1 M2. (iknows(M1) & M1 = tuple(M2)) => M2 = f_file(?) ) ); 	% database access
}

body{ %of Environment
		%isInFS(secureFile);
		isInFS(htpwd);
	new Session(webapplication, database, filesystem);
}

}
