% -------------------------------------------------------------------------
% Simple authentication bypass of an authentication form via SQL-injection
% -------------------------------------------------------------------------

@symbolsenv
		%web application constants
		header_cookie : text;
		listselect : text;
		search, login : text;

		% messages tag
		tag1,tag2,tag3,tag4 : text;


		% database
		nonpublic users : message set;
		nonpublic username : text;
		nonpublic archive : message set;
		nonpublic bob : text;
		nonpublic password : text;
		nonpublic randomCol : text;

@webapp
		symbols
			Option,View,Ordering,Typeid: text;
			Username, Password, Cookie, File, RemoteShell, Path: message;
			IP: agent;
			SQLquery, SQLresponse, Search: message;
			NonceWA,NonceDB,NonceFS : text;

		body{


		while(true){
			select{

			on( ? *->* Actor: ?IP.http_request(search, u.s.?Search, none).tag1 ): {

							% arity problem
							SQLquery := randomCol.Search;

							NonceWA := fresh();
							nonceUsed(NonceWA);
							Actor *->* Database : query(archive,SQLquery).NonceWA;

							select{
									on(Database *->* Actor : ?SQLresponse.NonceWA):{
												% assert f : SQLresponse != username;
												Actor *->* IP : http_response(viewHistory,SQLresponse);
									}
							}
			}


			on( ? *->* Actor: ?IP.http_request(login, u.s.?Username.s.p.s.?Password, none).tag1 ):{

					NonceWA := fresh();
					SQLquery := sanitized(username.Username);
					Actor *->* Database : query(users,SQLquery).NonceWA;

					select{
						on(Database *->* Actor : ?SQLresponse.NonceWA):{
							Actor *->* IP: http_response(dashboard,SQLresponse); % add a value that check if an http_response is valid?
						}
					}}

			}%end select
		}%end while
		}%end body


@sessionbody
users->add(username.bob);
Database_string := bob;


@goals
 [](!(iknows(dashboard))); 			%data extraction + authentication bypass
