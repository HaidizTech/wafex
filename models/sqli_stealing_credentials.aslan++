% ---------------------------------------------------------------
% SQL injection that steals credentials and uses them to
% log in the application
% ---------------------------------------------------------------


@symbolsenv
		%web application constants
		insertPage, comment, destroy, destroyComment, login, credentials: text;
			% page sets
			nonpublic insertSet : message set;

		% messages tagss
		tag1,tag2,tag3,tag4 : text;

@webapp
symbols
			Com, Pass:  message;
			IP: agent;
			SQLquery, SQLresponse, Search, Val: message;
			NonceWA,NonceDB,NonceFS : text;
			WebNonce : text;


		body{


		while(true){
			select{

				% login page
				on( ?IP *->* Actor : http_request(login, credentials.s.?Pass, none).tag2.?WebNonce):{
						NonceWA := fresh();
						Actor *->* Database : new_query(insertSet,sanitized(Pass)).NonceWA;
						Database *->* Actor : no_tuple.NonceWA;
						Actor *->* IP : http_response(dashboard,Val).tag2.WebNonce;
						%assert g: Val != xss.insertPage;
				}
				% read comment page
				on( ?IP *->* Actor : http_request(destroy, comment.s.?Com, none).tag3.?WebNonce):{
						NonceWA := fresh();
						Actor *->* Database : new_query(insertSet,Com).NonceWA;
						Database *->* Actor : ?Val.NonceWA;
						Actor *->* IP : http_response(insertPage,Val).tag2.WebNonce;
				}
		}
		}%end while
		}%end body


@goals
		%[](!(redirect(insertPage)));
		%[](!(iknows(hknows)));
		[](!(iknows(dashboard)));
		%[](!(iknows(tuple(?))));
		%[](!(insertSet->contains(?.xss)));

@bodyenv
		% isInFS(secureFile);
		% isInFS(htpwd);

		% this is a trick for giving the intruder the ability to send valid
		% credentials in case of a sanitized query at the beginning of
		% an execution. However is bad and does not make sense. Remove this
		% and block the ability of the database to perform file write in
		% order to generate the trace you'are expecting
		% iknows(tuple(sqli));
