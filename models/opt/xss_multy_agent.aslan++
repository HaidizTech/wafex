% -------------------------------------------------------------------------
% Testing XSS and multiple agents
% -------------------------------------------------------------------------

@symbolsenv

		%web application constants
		header_cookie : text;
		username : text;
		password : text;
		listselect : text;
		index, login, error : text;
		test : text;
		nonpublic test_back : text;

		% messages tag
		tag1,tag2,tag3,tag4 : text;

@webapp
		symbols
			Username, Password  : message;
			Cookie : mytype;
			IP, Entity: agent;
			Test, File, Path : message;
			SQLquery, SQLresponse, Search: message;
			NonceWA,NonceDB,NonceFS, NonceH : text;

		body{


		while(true){
			select{

				% HTTP login form
				on( ?Entity *->* Actor: ?IP.http_request(index, u.s.?Username.s.p.s.?Password, none).tag1.?NonceH ):{
						assert o: Entity != Honest | Username != xss.? | !hknows->contains(?) ;
						NonceWA := fresh();
						SQLquery := Username;
						Actor *->* Database : query2(SQLquery).NonceWA;
						select{
								on(Database *->* Actor : no_tuple.NonceWA):{
										Actor *->* Entity : http_response(error, Username).NonceH.tag1;
								}
								on(Database *->* Actor : tuple(?SQLresponse).NonceWA):{
										Cookie := fresh();
										cookieUsed(Cookie);
										Actor *->* Entity : http_response(dashboard, Cookie).NonceH.tag1;
						}}% internal select
				} % end on

				% Honest agent is performing login, so we don't need the database
				% this will save us some states, some timing and steps in the MSC
				on( Honest *->* Actor: ?IP.http_request(index, u.s.?Username.s.p.s.?Password, none).tag3.?NonceH ):{	
					%	NonceWA := fresh();
					%	SQLquery := Username;
					%	Actor *->* Database : query(SQLquery).NonceWA;
					%	select{
					%		on(Database *->* Actor : no_tuple.?NonceDB):{
					%			select{on(!nonceUsed(NonceDB)):{
										Cookie := fresh();
										cookieUsed(Cookie);
										Actor *->* Honest: http_response(dashboard,Cookie).NonceH.tag3;
					%			}}
					%	}}% internal select
				} % end on

				% file-upload
				on( ?Entity *->* Actor: ?IP.http_request(index,file.s.?File,?Cookie).tag1.?NonceH):{
						 select{on((cookieUsed(Cookie))):{
								NonceWA := fresh();
								Actor *->* Filesystem : writeFile(File).NonceWA;
						}}
				}

				 % this branch represents an uploaded server-side code that
				 % reads from the filesystem
				 on( i *->* Actor : ?IP.http_request(evil_file, file.s.?Path, none).tag2):{
				  	select{on( isInFS(evil_file) & evil_file != Path):{ % means the file Remote
				  			% retrieve is not the same as the injected file
				  			NonceWA := fresh();
				  			Actor *->* Filesystem : readFile(Path).NonceWA;
				  			%assert b:false;
				  			Filesystem *->* Actor : file(Path).NonceWA;
				  			Actor *->* i : http_response(Path, file(Path));
				  	}}
				 }
			}%end select
		}%end while
		}%endbody

@bodyenv
iknows(dashboard);

@goals
 % redirection goal
  %[](!(redirect(index))); 

 % hijacking goal
 %[](!iknows(hknows));
 %[](!cookieUsed(?));
 %[](!(exists C. iknows(C) & cookieUsed(C)));
 %[](!(exists C. hknows->contains(C) & cookieUsed(C) & iknows(hknows)));
 %[](!iknows(test_back));
 [](!iknows(file(?)));
