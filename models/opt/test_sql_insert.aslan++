% -------------------------------------------------------------------------
% Testing XSS and multiple agents
% -------------------------------------------------------------------------

@symbolsenv

		%web application constants
		header_cookie : text;
		username : text;
		password : text;
		listselect : text;
		public : text;
		index, login, error, random_page: text;
		test : text;
		nonpublic test_back : text;
		http(message) : message;
		% messages tag
		tag1,tag2,tag3,tag4 : text;

		nonpublic valid_user : text;

@webapp
		symbols
				Cookie : message;
				Value : message;
				Username, Password  : message;
				IP, Entity: agent;
				Test, File, Path : message;
				SQLquery, SQLresponse, Search, Response: message;
				NonceWA,NonceDB,NonceFS, NonceH : text;
				Dash_set : message set;
				Dash_string : message;

		body{
		Dash_set->add(valid_user);

		while(true){
			select{
				% insert request
				% on( ?Entity *->* Actor : ?IP.http_request(random_page, u.s.?Value, none).tag1.?NonceH ):{
				% 		NonceWA := fresh();
				% 		Actor *->* Database : insert(Dash_set,Value).NonceWA;
				% 		select{
				% 				on(Database *->* Actor : no_tuple.NonceWA):{
				% 						Actor *->* Entity : http_response(random_page,none).NonceH;
				% 						Dash_string := Value.Dash_string;
				% 				}
				% 				on(Database *->* Actor : tuple(?SQLresponse).NonceWA):{
				% 						Actor *->* Entity : http_response(random_page,tuple(SQLresponse));
				% 				}
				% 		}
				% }

				% login form
				on( ?Entity *->* Actor : ?IP.http_request(index, u.s.?Username.s.p.s.?Password, none).tag1.?NonceH ):{
						NonceWA := fresh();
						SQLquery := Username;
						Actor *->* Database : query3(Dash_set,SQLquery).NonceWA;
						select{
								on(Database *->* Actor : ?Response.NonceWA):{
										if(Response = no_tuple){
												Actor *->* Entity : http_response(index,none).NonceH;
										}else{
												Actor *->* Entity : http_response(dashboard,Response).NonceH;
										}
								}
						}
				}

				% get the content from a page
				on( ?Entity *->* Actor : ?IP.http_request(random_page, none, none).tag3.?NonceH ):{
						Actor *->* Entity : http_response(random_page,Dash_string).NonceH.tag3;
										%assert t : Entity != Honest | !Dash_set->contains(xss.index);
										assert tt : Entity != Honest | Dash_string != xss.?;
						%assert t : Entity != Honest | !Dash_set->contains(xss);
				}

				% HTTP login form
				%on( Honest *->* Actor: ?IP.http_request(index, u.s.?Username.s.p.s.?Password, none).tag1.?NonceH ):{
				%		NonceWA := fresh();
				%		SQLquery := Username;
				%		Actor *->* Database : query2(SQLquery).NonceWA;
				%		select{
				%				on(Database *->* Actor : no_tuple.NonceWA):{
				%						Actor *->* Honest : http_response(error, Username).NonceH.tag1;
				%						%assert c : !hknows->contains(?) | Username != xss;
				%				}
				%				on(Database *->* Actor : tuple(?SQLresponse).NonceWA):{
				%						Cookie := fresh();
				%						cookieUsed(Cookie);
				%						Actor *->* Honest : http_response(random_page, Cookie).NonceH.tag1;
				%		}}% internal select
				%} % end on
				
				%on( Honest *->* Actor: ?IP.http_request(random_page,p.s.?File,?Cookie).tag1.?NonceH):{
				%		 select{on((cookieUsed(Cookie))):{
				%				NonceWA := fresh();
				%				Actor *->* Database : query(File).NonceWA;
				%				select{ on(Database *->* Actor : tuple(?SQLresponse).NonceWA):{
				%						%assert t : File != sqli.path_injection.?.?;% | !hknows->contains(?);
				%						Actor *->* Honest : http_response(random_page,tuple(SQLresponse)).NonceH.tag1;
				%				}}
				%		}}
				%}

				% public page vulnerable to reflected XSS
				%on( Honest *->* Actor : ?IP.http_request(public,p.s.?Params,none).tag1.?NonceH):{
				%		Actor *->* Honest : http_response(public,Params).NonceH.tag1;
				%}

				% Honest agent is performing login, so we don't need the database
				% this will save us some states, some timing and steps in the MSC
				%on( Honest *->* Actor: ?IP.http_request(index, u.s.?Username.s.p.s.?Password, none).tag3.?NonceH ):{	
				%	%	NonceWA := fresh();
				%	%	SQLquery := Username;
				%	%	Actor *->* Database : query(SQLquery).NonceWA;
				%	%	select{
				%	%		on(Database *->* Actor : no_tuple.?NonceDB):{
				%	%			select{on(!nonceUsed(NonceDB)):{
				%						Cookie := fresh();
				%						cookieUsed(Cookie);
				%						Actor *->* Honest: http_response(random_page,Cookie).NonceH.tag3;
				%						%assert t: false;
				%	%			}}
				%	%	}}% internal select
				%} % end on

				% file-upload
				%on( ?Entity *->* Actor: ?IP.http_request(index,file.s.?File,?Cookie).tag1.?NonceH):{
				%		 select{on((cookieUsed(Cookie))):{
				%				NonceWA := fresh();
				%				Actor *->* Filesystem : writeFile(File).NonceWA;
				%		}}
				%}

				 % this branch represents an uploaded server-side code that
				 % reads from the filesystem
				 %on( i *->* Actor : ?IP.http_request(evil_file, file.s.?Path, none).tag2):{
				 % 	select{on( isInFS(evil_file) & evil_file != Path):{ % means the file Remote
				 % 			% retrieve is not the same as the injected file
				 % 			NonceWA := fresh();
				 % 			Actor *->* Filesystem : readFile(Path).NonceWA;
				 % 			%assert b:false;
				 % 			Filesystem *->* Actor : file(Path).NonceWA;
				 % 			Actor *->* i : http_response(Path, file(Path));
				 % 	}}
				 %}
			}%end select
		}%end while
		}%endbody

@bodyenv
%iknows(random_page);

@goals
 % redirection goal
  %[](!(redirect(index))); 

 % hijacking goal
 %[](!iknows(hknows));
 %[](!cookieUsed(?));
 %[](!(exists C. iknows(C) & cookieUsed(C)));
 %[](!(exists C. hknows->contains(C) & cookieUsed(C) & iknows(hknows)));
 %[](!iknows(test_back));

% Extraction goal goal
 %[](!iknows(file(?)));
%[]( !iknows(tuple(sqli)));
[]( !iknows(tuple(?)));

% Honest goal
%[](!hknows->contains(dashboard));
